import os
import sys
import logging
import argparse
from typing import Dict, List, Any, Optional

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

# --- Path and Import Setup ---
try:
    from stable_baselines3 import PPO
    from radp.digital_twin.utils import constants as c
    from radp.digital_twin.rf.bayesian.bayesian_engine import BayesianDigitalTwin
    from radp.digital_twin.utils.cell_selection import perform_attachment
except ImportError as e:
    print(f"FATAL: Error importing necessary libraries: {e}."); sys.exit(1)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

TILT_SET_VISUALIZER = [float(t) for t in range(21)] # It is required that this matches the training configuration.

class CCOVisualizer:
    """
    Network performance is visualized by this class, with a comparison made between a baseline and a reinforcement learning (RL)-optimized configuration.
    """
    def __init__(self, bdt_model_path: str, rl_model_path: str, topology_path: str, config_path: str, base_ue_data_dir: str):
        self.base_ue_data_dir = base_ue_data_dir
        
        topology_df = pd.read_csv(topology_path)
        config_df = pd.read_csv(config_path)
        self.site_config_df_base = pd.merge(topology_df, config_df, on='cell_id', how='left')
        self.site_config_df_base['cell_el_deg'].fillna(TILT_SET_VISUALIZER[len(TILT_SET_VISUALIZER)//2], inplace=True)
        
        required_cols = {'hTx': 25.0, 'hRx': 1.5, 'cell_az_deg': 0.0, 'cell_carrier_freq_mhz': 2100.0}
        for col, val in required_cols.items():
            if col not in self.site_config_df_base.columns:
                self.site_config_df_base[col] = val

        logger.info("Loading BDT model map..."); self.bdt_model_map = BayesianDigitalTwin.load_model_map_from_pickle(bdt_model_path)
        logger.info(f"Loaded BDT map for {len(self.bdt_model_map)} cells.")

        logger.info("Loading RL agent..."); rl_model_path_zip = rl_model_path if rl_model_path.endswith(".zip") else f"{rl_model_path}.zip"
        self.rl_model = PPO.load(rl_model_path_zip)
        logger.info("RL agent loaded.")

        # Column constants are defined for internal use.
        self.COL_LON = getattr(c, 'LOC_X', 'loc_x'); self.COL_LAT = getattr(c, 'LOC_Y', 'loc_y')
        self.COL_CELL_LON = getattr(c, 'CELL_LON', 'cell_lon'); self.COL_CELL_LAT = getattr(c, 'CELL_LAT', 'cell_lat')
        self.COL_CELL_ID = getattr(c, 'CELL_ID', 'cell_id'); self.COL_UE_ID = 'ue_id'
        self.COL_RXPOWER_DBM = getattr(c, 'RXPOWER_DBM', 'rxpower_dbm')
        self.COL_RSRP_DBM = getattr(c, 'RSRP_DBM', 'rsrp_dbm')


    def _run_local_simulation(self, ue_data: pd.DataFrame, site_config: pd.DataFrame) -> pd.DataFrame:
        """
        A local RF simulation is executed and cell attachment is performed by this method.
        """
        all_preds_list = []
        for cell_id in site_config[self.COL_CELL_ID].unique():
            bdt_predictor = self.bdt_model_map.get(cell_id)
            if not bdt_predictor: continue
            
            cell_cfg_df = site_config[site_config[self.COL_CELL_ID] == cell_id]
            pred_frames = BayesianDigitalTwin.create_prediction_frames(site_config_df=cell_cfg_df, prediction_frame_template=ue_data)
            df_for_pred = pred_frames.get(cell_id)
            if df_for_pred is not None and not df_for_pred.empty:
                bdt_predictor.predict_distributed_gpmodel(prediction_dfs=[df_for_pred])
                all_preds_list.append(df_for_pred)
        
        if not all_preds_list: return pd.DataFrame()
        combined_preds = pd.concat(all_preds_list, ignore_index=True)
        return perform_attachment(combined_preds, site_config)

    def _plot_scenario(self, ax, title: str, ue_data: pd.DataFrame, attached_data: pd.DataFrame):
        """
        A single subplot is generated by this helper method.
        """
        ax.set_title(title, fontsize=16)
        
        merge_keys = [self.COL_LON, self.COL_LAT]
        plot_df = pd.merge(ue_data, attached_data, on=merge_keys, how="left")
        plot_df.rename(columns={self.COL_CELL_ID: 'serving_cell_id'}, inplace=True)
        
        # UEs are plotted and colored according to their serving cell.
        legend_handles = []
        
        # A list of all cells serving at least one UE is obtained.
        unique_serving_cells = sorted(plot_df["serving_cell_id"].dropna().unique())
        
        # A color map is created to assign a unique color to each serving cell.
        if unique_serving_cells:
            cmap = plt.get_cmap("tab20", len(unique_serving_cells))
            for i, cell_id in enumerate(unique_serving_cells):
                cell_ues = plot_df[plot_df["serving_cell_id"] == cell_id]
                color = cmap(i)
                ax.scatter(cell_ues[self.COL_LON], cell_ues[self.COL_LAT], color=color, s=10, alpha=0.8)
                legend_handles.append(Line2D([0], [0], marker='o', color='w', label=f'UEs ({cell_id})',
                                             markerfacecolor=color, markersize=8))
        
        # UEs not connected to any cell are plotted.
        unserved_ues = plot_df[plot_df['serving_cell_id'].isna()]
        if not unserved_ues.empty:
            ax.scatter(unserved_ues[self.COL_LON], unserved_ues[self.COL_LAT], c='gray', marker='x', s=15, label="Disconnected UEs")
            legend_handles.append(Line2D([0], [0], marker='x', color='gray', linestyle='None', markersize=8, label='Disconnected UEs'))


        # All cell towers are plotted and labeled.
        ax.scatter(self.site_config_df_base[self.COL_CELL_LON], self.site_config_df_base[self.COL_CELL_LAT], 
                   marker='^', c='red', s=120, edgecolors='black', label='Cell Towers')
        legend_handles.append(Line2D([0], [0], marker='^', color='w', label='Cell Towers',
                                     markerfacecolor='red', markeredgecolor='black', markersize=12))

        # Text labels are added next to each tower.
        for i, row in self.site_config_df_base.iterrows():
            ax.text(row[self.COL_CELL_LON] + 0.001, row[self.COL_CELL_LAT], row[self.COL_CELL_ID], fontsize=9, ha='left')

        ax.set_xlabel("Longitude"); ax.set_ylabel("Latitude"); ax.grid(True, linestyle='--', alpha=0.4)
        ax.legend(handles=legend_handles, loc='best', fontsize='small')


    def generate_comparison_plots(self, day: int, tick: int, output_dir: str):
        """
        A side-by-side comparison plot is generated and saved by this method.
        """
        ue_data_dir = os.path.join(self.base_ue_data_dir, f"Day_{day}", "ue_data_gym_ready")
        ue_data_file = os.path.join(ue_data_dir, f"generated_ue_data_for_cco_{tick}.csv")
        if not os.path.exists(ue_data_file):
            logger.error(f"Test UE data file not found: {ue_data_file}"); return
        
        ue_data_df = pd.read_csv(ue_data_file)
        if 'mock_ue_id' in ue_data_df.columns:
             ue_data_df.rename(columns={'mock_ue_id': self.COL_UE_ID}, inplace=True)
        elif self.COL_UE_ID not in ue_data_df.columns:
             ue_data_df[self.COL_UE_ID] = range(len(ue_data_df))


        # The baseline scenario (initial tilts) is simulated.
        logger.info("Simulating baseline scenario (initial tilts)...")
        baseline_attached_df = self._run_local_simulation(ue_data_df, self.site_config_df_base)

        # The RL-optimized scenario is simulated.
        logger.info("Simulating RL-optimized scenario...")
        action_indices, _ = self.rl_model.predict(tick, deterministic=True)
        
        opt_config_df = self.site_config_df_base.copy()
        for i, cell_action_idx in enumerate(action_indices):
            cell_id = self.site_config_df_base[self.COL_CELL_ID].iloc[i]
            opt_config_df.loc[opt_config_df[self.COL_CELL_ID] == cell_id, getattr(c,'CELL_EL_DEG','cell_el_deg')] = TILT_SET_VISUALIZER[cell_action_idx]

        required_cols = {'hTx': 25.0, 'hRx': 1.5}
        for col, val in required_cols.items():
            if col not in opt_config_df.columns:
                opt_config_df[col] = val
        optimized_attached_df = self._run_local_simulation(ue_data_df, opt_config_df)

        # The plots are generated.
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 10), sharex=True, sharey=True)
        fig.suptitle(f'Load Balancing CCO Comparison for Day {day}, Tick {tick}', fontsize=20)

        self._plot_scenario(ax1, 'Baseline: Initial Configuration', ue_data_df, baseline_attached_df)
        self._plot_scenario(ax2, 'Optimized: RL Agent Configuration', ue_data_df, optimized_attached_df)

        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, f"cco_comparison_day{day}_tick_{tick}.png")
        plt.savefig(output_path, bbox_inches='tight')
        logger.info(f"Comparison plot saved to: {output_path}")
        plt.close(fig)
