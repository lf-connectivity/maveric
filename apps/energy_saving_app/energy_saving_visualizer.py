import logging
import os
import sys

import matplotlib.pyplot as plt
import pandas as pd

try:
    from stable_baselines3 import PPO

    from radp.digital_twin.rf.bayesian.bayesian_engine import BayesianDigitalTwin
    from radp.digital_twin.utils import constants as c
    from radp.digital_twin.utils.cell_selection import perform_attachment
except ImportError as e:
    print(f"FATAL: Error importing libraries: {e}.")
    sys.exit(1)

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

TILT_SET = [0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0, 20.0]


class EnergySavingVisualizer:
    """
    The visualization of network performance is performed by this class,
    in which a baseline configuration is compared to an RL-optimized configuration.
    """

    def __init__(
        self, bdt_model_path: str, rl_model_path: str, topology_path: str, config_path: str, base_ue_data_dir: str
    ):
        self.base_ue_data_dir = base_ue_data_dir

        topology_df = pd.read_csv(topology_path)
        config_df = pd.read_csv(config_path)
        self.site_config_df_base = pd.merge(topology_df, config_df, on="cell_id", how="left")
        self.site_config_df_base["cell_el_deg"].fillna(TILT_SET[len(TILT_SET) // 2], inplace=True)

        required_cols = {"hTx": 25.0, "hRx": 1.5, "cell_az_deg": 0.0, "cell_carrier_freq_mhz": 2100.0}
        for col, val in required_cols.items():
            if col not in self.site_config_df_base.columns:
                self.site_config_df_base[col] = val

        logger.info("Loading BDT model map...")
        self.bdt_model_map = BayesianDigitalTwin.load_model_map_from_pickle(bdt_model_path)
        logger.info(f"Loaded BDT map for {len(self.bdt_model_map)} cells.")

        logger.info("Loading RL agent...")
        rl_model_path_zip = rl_model_path if rl_model_path.endswith(".zip") else f"{rl_model_path}.zip"
        self.rl_model = PPO.load(rl_model_path_zip)
        logger.info("RL agent loaded.")

        self.COL_LON = getattr(c, "LOC_X", "loc_x")
        self.COL_LAT = getattr(c, "LOC_Y", "loc_y")
        self.COL_CELL_LON = getattr(c, "CELL_LON", "cell_lon")
        self.COL_CELL_LAT = getattr(c, "CELL_LAT", "cell_lat")
        self.COL_CELL_ID = getattr(c, "CELL_ID", "cell_id")
        self.COL_UE_ID = "mock_ue_id"  # Alignment with generated data is ensured
        self.COL_RXPOWER_DBM = getattr(c, "RXPOWER_DBM", "rxpower_dbm")
        self.COL_RSRP_DBM = getattr(c, "RSRP_DBM", "rsrp_dbm")

    def _run_local_simulation(self, ue_data: pd.DataFrame, site_config: pd.DataFrame) -> pd.DataFrame:
        """
        A local RF simulation is executed and cell attachment is performed by this method.
        """
        all_preds_list = []
        active_cell_ids = site_config[self.COL_CELL_ID].unique()
        for cell_id in active_cell_ids:
            bdt_predictor = self.bdt_model_map.get(cell_id)
            if not bdt_predictor:
                continue

            cell_cfg_df = site_config[site_config[self.COL_CELL_ID] == cell_id]
            pred_frames = BayesianDigitalTwin.create_prediction_frames(
                site_config_df=cell_cfg_df, prediction_frame_template=ue_data
            )
            df_for_pred = pred_frames.get(cell_id)
            if df_for_pred is not None and not df_for_pred.empty:
                bdt_predictor.predict_distributed_gpmodel(prediction_dfs=[df_for_pred])
                all_preds_list.append(df_for_pred)

        if not all_preds_list:
            return pd.DataFrame()
        combined_preds = pd.concat(all_preds_list, ignore_index=True)
        return perform_attachment(combined_preds, site_config)

    def _plot_scenario(
        self,
        ax,
        title: str,
        ue_data: pd.DataFrame,
        attached_data: pd.DataFrame,
        active_towers: pd.DataFrame,
        inactive_towers: pd.DataFrame,
        partial_towers: pd.DataFrame,
    ):
        """
        A single subplot is generated by this helper method, with UE color grouping based on cell tower (site) ID.
        """
        ax.set_title(title, fontsize=16)

        merge_keys = [self.COL_LON, self.COL_LAT]
        plot_df = pd.merge(ue_data, attached_data, on=merge_keys, how="left")
        plot_df.rename(columns={self.COL_CELL_ID: "serving_cell_id"}, inplace=True)

        served_ues = plot_df.dropna(subset=["serving_cell_id"]).copy()

        # Derive tower-wise site_id (e.g., cell_1 from cell_1_0)
        served_ues["site_id"] = served_ues["serving_cell_id"].str.rsplit("_", n=1).str[0]

        unique_sites = sorted(served_ues["site_id"].unique())

        # Define bold/primary colors
        base_colors = [
            "blue",
            "red",
            "green",
            "purple",
            "orange",
            "cyan",
            "magenta",
            "brown",
            "black",
            "navy",
            "darkgreen",
        ]
        color_map = {site: base_colors[i % len(base_colors)] for i, site in enumerate(unique_sites)}

        for site in unique_sites:
            site_ues = served_ues[served_ues["site_id"] == site]
            ax.scatter(
                site_ues[self.COL_LON],
                site_ues[self.COL_LAT],
                color=color_map[site],
                s=10,
                alpha=0.8,
                label=f"UEs (site_{site.split('_')[1]})",
            )

        no_serve_ues = plot_df[plot_df["serving_cell_id"].isna()]
        ax.scatter(
            no_serve_ues[self.COL_LON],
            no_serve_ues[self.COL_LAT],
            c="darkorange",
            marker="x",
            s=25,
            label="Disconnected UEs",
        )

        if not active_towers.empty:
            ax.scatter(
                active_towers[self.COL_CELL_LON],
                active_towers[self.COL_CELL_LAT],
                marker="^",
                c="green",
                s=150,
                edgecolors="black",
                label="Fully Active Sites",
                zorder=10,
            )
        if not inactive_towers.empty:
            ax.scatter(
                inactive_towers[self.COL_CELL_LON],
                inactive_towers[self.COL_CELL_LAT],
                marker="^",
                c="red",
                s=150,
                alpha=0.7,
                edgecolors="black",
                label="Fully Inactive Sites",
                zorder=10,
            )
        if not partial_towers.empty:
            ax.scatter(
                partial_towers[self.COL_CELL_LON],
                partial_towers[self.COL_CELL_LAT],
                marker="^",
                c="yellow",
                s=150,
                edgecolors="black",
                label="Partially Active Sites",
                zorder=10,
            )

        for i, row in self.site_config_df_base.iterrows():
            ax.text(
                row[self.COL_CELL_LON] + 0.001, row[self.COL_CELL_LAT], row[self.COL_CELL_ID], fontsize=9, ha="left"
            )

        ax.set_xlabel("Longitude")
        ax.set_ylabel("Latitude")
        ax.grid(True, linestyle="--", alpha=0.4)
        ax.legend(loc="best", fontsize="small")

    def generate_comparison_plots(self, day: int, tick: int, output_dir: str):
        """
        The comparison plots for the baseline and RL-optimized scenarios are generated and saved by this method.
        """
        ue_data_dir = os.path.join(self.base_ue_data_dir, f"Day_{day}", "ue_data_gym_ready")
        ue_data_file = os.path.join(ue_data_dir, f"generated_ue_data_for_cco_{tick}.csv")
        if not os.path.exists(ue_data_file):
            logger.error(f"Test UE data file not found: {ue_data_file}")
            return

        ue_data_df = pd.read_csv(ue_data_file)
        if self.COL_UE_ID not in ue_data_df.columns:
            logger.error(f"UE data file is missing required column: '{self.COL_UE_ID}'")
            return

        def attach_ues(predictions_df: pd.DataFrame):
            """
            The serving cell for each UE is determined by this function, based on the maximum received power.
            """
            if predictions_df.empty or self.COL_UE_ID not in predictions_df.columns:
                return pd.DataFrame()
            idx = predictions_df.groupby(self.COL_UE_ID)[self.COL_RXPOWER_DBM].idxmax()
            serving_data = predictions_df.loc[idx].copy()
            return serving_data

        site_id_col = getattr(c, "SITE_ID", "site_id")
        if site_id_col not in self.site_config_df_base.columns:
            self.site_config_df_base["site_id_temp"] = (
                self.site_config_df_base[self.COL_CELL_ID].str.rsplit("_", n=1).str[0]
            )
            site_id_col = "site_id_temp"
        site_locations = self.site_config_df_base.drop_duplicates(subset=[site_id_col]).copy()

        # --- 1. Baseline Scenario ---
        logger.info("Simulating baseline scenario (initial tilts, all cells on)...")
        baseline_attached_df = self._run_local_simulation(ue_data_df, self.site_config_df_base)
        baseline_active_towers = site_locations
        baseline_inactive_towers = pd.DataFrame()
        baseline_partial_towers = pd.DataFrame()

        # --- 2. Optimized Scenario ---
        logger.info("Simulating RL-optimized scenario...")
        action_indices, _ = self.rl_model.predict(tick, deterministic=True)

        active_cell_ids = []
        for i, cell_action_idx in enumerate(action_indices):
            if cell_action_idx < len(TILT_SET):
                active_cell_ids.append(self.site_config_df_base[self.COL_CELL_ID].iloc[i])

        active_topology_for_sim = self.site_config_df_base[
            self.site_config_df_base[self.COL_CELL_ID].isin(active_cell_ids)
        ]
        optimized_attached_df = self._run_local_simulation(ue_data_df, active_topology_for_sim)

        fully_active_sites, fully_inactive_sites, partially_active_sites = [], [], []
        for site_id, group in self.site_config_df_base.groupby(site_id_col):
            active_cells_in_site = set(group[self.COL_CELL_ID]).intersection(active_cell_ids)
            if not active_cells_in_site:
                fully_inactive_sites.append(site_id)
            elif len(active_cells_in_site) == len(group):
                fully_active_sites.append(site_id)
            else:
                partially_active_sites.append(site_id)

        opt_active_towers = site_locations[site_locations[site_id_col].isin(fully_active_sites)]
        opt_inactive_towers = site_locations[site_locations[site_id_col].isin(fully_inactive_sites)]
        opt_partial_towers = site_locations[site_locations[site_id_col].isin(partially_active_sites)]

        # --- 3. Generate Plots ---
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 10), sharex=True, sharey=True)
        fig.suptitle(f"Energy Saving Comparison for Test Day {day}, Tick {tick}", fontsize=20)

        self._plot_scenario(
            ax1,
            "Baseline: Initial Configuration",
            ue_data_df,
            baseline_attached_df,
            baseline_active_towers,
            baseline_inactive_towers,
            baseline_partial_towers,
        )
        self._plot_scenario(
            ax2,
            "Optimized: RL Agent Configuration",
            ue_data_df,
            optimized_attached_df,
            opt_active_towers,
            opt_inactive_towers,
            opt_partial_towers,
        )

        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, f"energy_saving_comparison_day{day}_tick_{tick}.png")
        plt.savefig(output_path, bbox_inches="tight")
        logger.info(f"Comparison plot saved to: {output_path}")
        plt.close(fig)
